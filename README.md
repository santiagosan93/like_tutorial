---
slug: "likes_with_stimulus_and_act_as_votable"
type: "text"
thumbnail: ''
title: "Likes in your Rails app"
description: "Implement like functionality within your models"
author_github_nickname: "santiagosan93"
category: "rails"

---

# Likes with  Stimulus + act_as_votable
## Getting started
In this tutorial we will learn how to incorporate ```likes``` into your Rails web application. In order to do this we will need the help of the ```acts_as_votable``` gem, and some basic understanding of ```stimulus```. It would be ideal for you to have a refresher on stimulus by checking out the ```AJAX in Rails``` lecture. You can view it at 1.5x speed and skip ahead to the second part of the lecture where they speak about stimulus.

To kick things off, we are going to start from scratch. We will implement an app with users and movies in which we will be able to like and unlike them using AJAX.

### First things first - Video starting point

```bash
cd ~/code/$YOUR_GITHUB_USERNAME
rails new \
  -T --database postgresql \
  -m https://raw.githubusercontent.com/lewagon/rails-templates/master/devise.rb \
  stimulus_likes
rails g model movie title
rails db:migrate
rails g controller movies index
```
Add faker to your project
```ruby
# Gemfile
gem 'faker'
```
```bash
bundle install
```

Set your routes!
```ruby
# routes.rb
Rails.application.routes.draw do
  devise_for :users
  root to: 'pages#home'

  resources :movies, only: :index
end
```

Implement the index action.
```ruby
# movies_controller.rb
class MoviesController < ApplicationController
  def index
    @movies = Movie.all
  end
end
```

Implement the views
```erb
<!-- app/views/movies/index.html.erb -->
<div class="container">
  <h1>Here are all the movies</h1>
  <div class="movie-cards">
    <% @movies.each do |movie| %>
      <%= render 'movies/card', movie: movie %>
    <% end %>
  </div>
</div>
```

```erb
<!-- app/views/movies/_card.html.erb -->
<div class="movie-card position-relative d-flex justify-content-center align-items-center">
  <p><%= movie.title %></p>
  <%= render 'heart', movie: movie %>
</div>
```

```erb
<!-- app/views/movies/_heart.html.erb -->
<i class="far fa-heart heart"></i>

```

And lastly add the css.

```scss
// app/assets/stylesheets/components/_card.scss
.movie-card {
  background: linear-gradient(
    180deg,
    rgba(40, 40, 40, 0.5),
    rgba(40, 40, 40, 0.5)),
    url(https://picsum.photos/200/300)
  ;
  height: 200px;
  background-size: cover;
  background-position: center;
  color: white;
  font-weight: bold;
  font-size: 20px;
  border-radius: 6px;
  box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
  padding: 0px 24px;
  text-align: center;
  .heart {
    position: absolute;
    top: 8px;
    right: 8px;
    color: #e75480;
    &:hover {
      cursor: pointer;
    }
  }
}


.movie-cards {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-gap: 20px;

}
```

Don't forget to import the partial in your components/index.scss !!!ðŸš¨ ðŸš¨


## Act as votable

### Introduction
Ok now that we have everything set up, we can start talking about acts_as_votable and how it works. acts_as_votable is a Ruby Gem specifically written for Rails/ActiveRecord models. The main goals of this gem are:

Allow any model to be voted on, like/dislike, upvote/downvote, etc.
Allow any model to be voted under arbitrary scopes.
Allow any model to vote. In other words, votes do not have to come from a user, they can come from any model (such as a Group or Team).


### Install

Just add the following to your Gemfile to install the latest release.

```ruby
gem 'acts_as_votable'
```

And follow that up with a ``bundle install``.

### Database Migrations

acts_as_votable uses a ```votes``` table to store all voting information.  To
generate and run the migration just use.
```bash
  rails generate acts_as_votable:migration
  rails db:migrate
```

This ```votes``` table generated by acts_as_votable is going to be our join table between movies and users. In case it helps you, votes can be interpreted as likes.

## Usage
In this part we have to tell our models which model is going to be the liker/voter, and who is going to be the voted/liked. In our case, the User is going to be the liker/voter, and the Movie is going to be the liked/voted.

In order to represent this in our code, we have to write the following lines in our models.

For the user
```ruby
class User < ApplicationRecord
  # ...
  acts_as_voter
end
```


For the Movie
```ruby
class Movie < ApplicationRecord
  # ...
  acts_as_votable
end
```

As you can see here we are explicitly telling acts_as_votable that our liker is going to be the User, and the model that is going to receive those likes, is the Movie.


## Methods available --> Release the magic!

```ruby
  # Like a movie
  @movie.liked_by(@user)

  # Unlike a movie
  @movie.unliked_by(@user)

  #Find out if a user likes a certain movie
  @user.liked?(@movie)

  # Get all the liked movies from a user
  current_user.get_up_voted(Movie)
```

Now here with this arsenal we have everything to create/destroy likes in our movies.

## Lets crash test this
If you added the seeds that come with this tutorial, you can copy paste these lines inside of your ```rails console``` just the way they are. If not, you will have to adapt them to your current needs.

Let's start by making our first user of our database like a random movie.

```ruby
 # rails c
 user = User.first
 movie = Movie.sample

 movie.liked_by(user)
 # => Creates the like inside of your databse

```

As soon as you run these lines, you will see a vote being inserted into our DB. The key values of this vote record are the ```voter_id```, and the ```votable_id```. You will see that the voter_id corresponds to the first user since the user is the voter, and the votable_id will correspond to the id of the movie we're liking.

Now we can run the next method in our arsenal to check if a user has liked a specific movie.

```ruby
 user.liked?(movie)
 # => true
```

If you check with another movie that is not the one assigned to our ```movie``` variable, it will return ```false```.


## Update the views
Now the we have a way to know if a user has liked a movie, we can update our views so that they display either a full or empty heart.

```erb
<!-- app/views/movies/_heart.html.erb -->
  <i class="<%= current_user.liked?(movie) ? 'fas' : 'far' %> fa-heart heart"></i>
```
Above we have set a ternary to be in charge of adjusting one of the classes of the heart between ```fas``` and ```far``` depending on if the the user has liked the movie in the current iteration or not.

# Stimulus
Now to the fun part. We have everything ready to go, but we need to start adding listeners to our hearts, and make them fire an AJAX request. In order for us to achieve this we will set up stimulus in our app.

```bash
# If you havn't run the stimulus installer
rails webpacker:install:stimulus

touch app/javascript/controllers/likes_controller.js
```
Now we have installed stimullus and we have also created our first stimulus controller. Now let's implement a basic stimulus controller skeleton.

```js
import { Controller } from "stimulus"

export default class extends Controller {
  connect() {
    console.log('We are connected to the likes controller')
  }
}

````

As much as we would like to see this console log on our page as soon as we refresh, it wont happen since we haven't connected to our stimulus controller from our HTML.


```erb
# movies/index.html.erb

<div class="container">
  <h1>Here are all the movies</h1>
  <div class="movie-cards" data-controller="likes">
    <% @movies.each do |movie| %>
      <%= render 'movies/card', movie: movie %>
    <% end %>
  </div>
</div>

```

And just by adding the data set ```data-controller="likes"``` our connection between our view and our stimulus controller will be implemented. Now if you refresh your page, you will see in your console the console.log that we wrote in the ```likes_controller.js```

Moving on, now we can react to a click on the heart. To do this we have to add the data set ```data-action``` to our heart element and then set it's value. The value is composed of two parts, the first one is the event type (In this case click) and the second one is the controller plus the action( In this case likes#updateHeart). Additionally we are going to add the extra data attributes to our heart so that we can be a step ahead when creating the path for our AJAX call.

```erb
# _heart.html.erb
<i class="<%= current_user.liked?(movie) ? 'fas' : 'far' %> fa-heart heart"
  data-action="click->likes#updateLike"
  data-movie-id="<%= movie.id %>"
  data-method="<%= current_user.liked?(movie) ? 'delete' : 'post' %>">
</i>
```

Still, this is not enough to have something working since we are specifying in the  data-action attribute that the action ```updateLike``` will be fired on click. But right now we don't have that action written in our stimulus controller, so that would be the next step.

```js
import { Controller } from "stimulus"
import Rails from "@rails/ujs";

export default class extends Controller {
  connect() {
    console.log('We are connected to the likes controller')
  }

  updateLike(event) {
    const heart = event.currentTarget
    const movieId = heart.dataset.movieId
    const method = heart.dataset.method
    Rails.ajax({
      type: method,
      url: `/movies/${movieId}/like`,
      success: (data) => {
        heart.outerHTML = data.heart
      }
    })
  }
}
````

Here we have defined our updateLike action, and this way our click event in the heart will no longer show an error when we click it. What's happening in this function, is that first we are subtracting all of the information from our heart needed to make the request that we want. So we have the ```movieId``` and the ```method``` of the request we want to make. Then we use this information to create our path inside of our ```Rails.ajax``` function and we expect that this call returns an updated heart (after click) so that we can replace the old heart (before click) with it.


Now we need to update our routes to have these two new routes in charge of creating and deleting a like.

```ruby
Rails.application.routes.draw do
  devise_for :users
  root to: 'pages#home'

  resources :movies, only: :index do
    member do
      post :like, to: 'likes#create', defaults: { format: :json }
      delete :like, to: 'likes#destroy', defaults: { format: :json }
    end
  end
end
```
Now that our routes have been set, we now have to implement the likes_controller.rb file with the corresponding actions: ```create``` and ```destroy```

```ruby
class LikesController < ApplicationController
  before_action :set_movie

  def create
    @movie.liked_by current_user
    render json: {
      message: 'like created',
      heart: heart_to_string
    }
  end

  def destroy
    @movie.unliked_by current_user
    render json: {
      message: 'like deleted',
      heart: heart_to_string
    }
  end

  private

  def set_movie
    @movie = Movie.find(params[:id])
  end

  def heart_to_string
    render_to_string(
        partial: 'movies/heart.html.erb',
        locals: { movie: @movie }
      )
  end
end
```

Here we have implemented the ```create``` and ```destroy``` method to create/delete a like in our database, and respond with an up to date heart, which is being handled in our ```success``` key inside of our Rails.ajax.

```js
success: (data) => {
  heart.outerHTML = data.heart
}
````


Happy Hacking!!!

